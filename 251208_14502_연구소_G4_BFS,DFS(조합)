//O( (NM C 3) * NM) -> /N*M C 3은 ~= (NM)^3 -> O((NM)^4)
//dfs로 조합의 수를 찾고 그 수에 맞게 벽을 세운 상황에따라 모두 bfs를 돌려 수를 셌음.

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int N, M,result;
vector<vector<int>> arr;
vector<vector<int>> original_arr;
vector<pair<int, int>> cordi;
vector<pair<int, int>> seq;
vector<vector<pair<int, int>>> three_cordi;
vector<pair<int, int>> virus;


void dfs(int n) {
	if (seq.size() == 3) {
		three_cordi.push_back(seq);
		return;
	}
	for (int i = n+1; i < cordi.size(); i++) {
		seq.push_back(cordi[i]);
		dfs(i);
		seq.pop_back();
	}
}

void bfs() {
	queue<pair<int, int>> q;
	for (int i = 0; i < virus.size(); i++) {
		q.push(virus[i]);
	}

	int dirx[] = {0,0,1,-1};
	int diry[] = { 1,-1,0,0 };
	while (!q.empty()) {
		int curx = q.front().first;
		int cury = q.front().second;
		q.pop();

		for (int i = 0; i < 4; i++) {
			int forx = dirx[i] + curx;
			int fory = diry[i] + cury;

			if (forx < 0 or forx >= N or fory < 0 or fory >= M) continue;
			if (arr[forx][fory] != 0) continue;

			arr[forx][fory] = 2;
			q.push({ forx,fory });
		}
	}
	int answer = 0;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			if (arr[i][j] == 0) {
				answer++;
			}
		}
	}

	result = max(result, answer);
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	cin >> N >> M;
	arr.assign(N, vector<int>(M, 0));
	original_arr.assign(N, vector<int>(M, 0));
	result = 0;

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> original_arr[i][j];
			if (original_arr[i][j] == 0)
				cordi.push_back({ i,j });
			if (original_arr[i][j] == 2)
				virus.push_back({ i,j });
		}
	}

	dfs(-1);
	for (int i = 0; i < three_cordi.size(); i++) {
		for (int j = 0; j < N; j++) {
			for (int k = 0; k < M; k++) {
				arr[j][k] = original_arr[j][k];
			}
		}

		for (int j = 0; j < 3; j++) {
			arr[three_cordi[i][j].first][three_cordi[i][j].second] = 1;
		}

		bfs();
	}

	cout << result;
}	
