//O(n*m)
//벽을 부순적 있을때와 안부순적 있을 때를 visited를 한차원 늘려서 확인함으로 해결.
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int n, m;
	cin >> n >> m;
	vector<vector<int>> arr;
	vector<vector<vector<int>>> visited;
	visited.assign(n, vector<vector<int>>(m, vector<int>(2,0) ));
	arr.assign(n, vector<int>(m, 0));
		
	for (int i = 0; i < n; i++) {
		string line;
		cin >> line;
		for (int j = 0; j < m; j++) {
			arr[i][j] = line[j] - '0';
		}
	}

	queue<pair<int,pair<int,int>>> q;
	q.push({ 0,{ 0, 0 } });
	visited[0][0][0] = 1;
	int dirn[] = { 0, 0, 1, -1 };
	int dirm[] = { 1, -1, 0, 0 };

	while (!q.empty()) {
		int curn = q.front().first;
		int curm = q.front().second.first;
		int broken = q.front().second.second;
		q.pop();

		if (curn == n - 1 && curm == m - 1) {
			cout << visited[curn][curm][broken] << "\n";
			return 0;
		}

		for (int i = 0; i < 4; i++)	{
			int forn = dirn[i] + curn;
			int form = dirm[i] + curm;
			if (forn < 0 or forn >= n or form <0 or form >= m) continue;

			if (arr[forn][form] == 0 and visited[forn][form][broken] == 0) {
				visited[forn][form][broken] = visited[curn][curm][broken] + 1;
				q.push({ forn,{form,broken} });
			}
			if (arr[forn][form] == 1 and broken == 0 and visited[forn][form][1] == 0) {
				visited[forn][form][1] = visited[curn][curm][0] + 1;
				q.push({ forn, {form, 1} });
			}
		}	
	}

	cout << -1;

}
