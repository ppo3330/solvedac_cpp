//O(M log N)
//처음에 bfs를 사용했더니 O(N*M)이 되므로 실패.다익스트라는  우선순위 큐를 통해 불필요한 재탐색 시간을 줄이므로 시간복잡도가 줄어듬
//이 겨우 시간은 똑같았으나 priority_queue에서 pair를 쓸경우 first를 기준으로 정렬됨. 실제 시간은 다를 수 있으므로 주의.
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int N, M;
	vector<vector<pair<int, int>>> cities;

	cin >> N;
	cities = vector<vector<pair<int, int>>>(N + 1);

	cin >> M;
	for (int i = 0; i < M; i++) {
		int st, ed, cost;
		cin >> st >> ed >> cost;
		cities[st].push_back({ ed,cost });
	}

	int start_city, end_city;
	cin >> start_city >> end_city;

	vector<int> dist(N + 1, 1e9);
	dist[start_city] = 0;
	priority_queue < pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

	pq.push({ start_city,0 });
	while (!pq.empty()) {
		int cur_city = pq.top().first;
		int cur_cost = pq.top().second;
		pq.pop();

		if (cur_cost > dist[cur_city]) continue;
		for (int i = 0; i < cities[cur_city].size();i++) {
			int next_city = cities[cur_city][i].first;
			int next_cost = cities[cur_city][i].second;
			int new_cost = cur_cost + next_cost;

			if (new_cost < dist[next_city]) {
				dist[next_city] = new_cost;
				pq.push({ next_city, new_cost });
			}
		}
	}
	cout << dist[end_city];
}
