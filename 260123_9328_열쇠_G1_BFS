//O(T * h * w)
//DFS쓰면 시간초과가 나올거임. DFS를 쓸때는 방문한 칸을 다시 방문할 일이 없을때임.
//분기별로 나누는게 생각보다 어려웠음. 
//key는 비트마스킹을 이용했음. 그러나 그냥 key[26]으로 했어도 됐을듯 이게 더 빨랐을 듯.
//map.assign(h + 2, string(w + 2, '.')); 방식 기억하기

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

vector<string> map;

vector<vector<pair<int, int>>> cords(27);
int h, w;
int result;

int dirx[] = { 0,0,1,-1 };
int diry[] = { 1,-1,0,0 };


int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int T;
	cin >> T;
	vector<int> results;
	while (T > 0) {
		T--;

		int keys = 0;

		cin >> h >> w;
		map.assign(h + 2, string(w + 2, '.'));
		for (int i = 1; i < h+1; i++) {
			string s;
			cin >> s;
			for (int j = 1; j < w+1; j++) {
				map[i][j] = s[j - 1];
			}
		}

		string key;
		cin >> key;
		if (key[0] != '0') {
			for (int i = 0; i < key.size(); i++) {
				keys = keys | (1 << (key[i] - 'a'));
			}
		}
		result = 0;

		queue<pair<int,int>> q;
		map[0][0] = '*';
		q.push({ 0,0 });
		while (!q.empty()) {
			int curx = q.front().first;
			int cury = q.front().second;
			q.pop();

			for (int i = 0; i < 4; i++) {
				int forx = dirx[i] + curx;
				int fory = diry[i] + cury;
				
				if (forx < 0 or forx >= h + 2 or fory < 0 or fory >= w + 2) continue;
				char nxt = map[forx][fory];
				if (nxt == '*') continue;

				else if (nxt == '.') {
					map[forx][fory] = '*'; 
					q.push({ forx,fory });
				}
				else if (nxt >= 'a' and nxt <= 'z') {
					if (!(keys & (1 << (nxt - 'a')))) {
						keys = keys | (1 << (nxt - 'a'));
						for (int j = 0; j < cords[nxt - 'a'].size(); j++) {
							map[cords[nxt - 'a'][j].first][cords[nxt - 'a'][j].second] = '*';
							q.push({ cords[nxt - 'a'][j].first, cords[nxt - 'a'][j].second});
						}
						cords[nxt - 'a'].clear();
					}
					map[forx][fory] = '*';
					q.push({ forx,fory });
				}
				else if (nxt >= 'A' and nxt <= 'Z') {
					if (keys & (1<<(nxt - 'A'))) {
						map[forx][fory] = '*';
						q.push({ forx,fory });
					}
					else {
						cords[nxt-'A'].push_back({forx,fory});
					}
				}
				else if (nxt == '$') {
					result++;
					map[forx][fory] = '*';
					q.push({ forx,fory });
				}
			}
		}

		for (int i = 0; i < 26; i++) {
			cords[i].clear();
		}

		results.push_back(result);
	}
	for (int i = 0; i < results.size(); i++) {
		cout << results[i] << "\n";
	}
}




