//O(N*M)
//부르트포스로 모든 도형에 대해 구현
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int tetr1_1(const vector<vector<int>>& arr, int N, int M, int i, int j) {
	if (j + 3 < M) {
		return arr[i][j] + arr[i][j + 1] + arr[i][j + 2] + arr[i][j + 3];
	}
	return 0;
}
int tetr1_2(const vector<vector<int>>& arr, int N, int M, int i, int j) {
	if (i + 3 < N) {
		return arr[i][j] + arr[i+1][j] + arr[i+2][j] + arr[i+3][j];
	}
	return 0;
}

int tetr234_1(const vector<vector<int>>& arr, int N, int M, int i, int j) {
	if (j + 2 < M && i + 1 < N) {
		vector<int> result;
		result.push_back(arr[i][j] + arr[i][j + 1] + arr[i][j + 2] + arr[i + 1][j + 2]);//ㄱ
		result.push_back(arr[i + 1][j] + arr[i + 1][j + 1] + arr[i + 1][j + 2] + arr[i][j + 2]);//ㅢ
		result.push_back(arr[i][j] + arr[i][j + 1] + arr[i][j + 2] + arr[i + 1][j]);//r
		result.push_back(arr[i][j] + arr[i + 1][j] + arr[i + 1][j + 1] + arr[i + 1][j + 2]);//ㄴ

		result.push_back(arr[i + 1][j] + arr[i + 1][j + 1] + arr[i][j + 1] + arr[i][j + 2]);
		result.push_back(arr[i][j] + arr[i][j + 1] + arr[i + 1][j + 1] + arr[i + 1][j + 2]);
		
		result.push_back(arr[i][j] + arr[i][j + 1] + arr[i][j + 2] + arr[i + 1][j + 1]);
		result.push_back(arr[i + 1][j] + arr[i + 1][j + 1] + arr[i + 1][j + 2] + arr[i][j + 1]);

		return *max_element(result.begin(), result.end());
	}
	return 0;
}
int tetr234_2(const vector<vector<int>>& arr, int N, int M, int i, int j) {
	if (i + 2 < N && j + 1 < M) {
		vector<int> result;
		result.push_back(arr[i][j] + arr[i][j + 1] + arr[i + 1][j] + arr[i + 2][j]);
		result.push_back(arr[i][j] + arr[i][j + 1] + arr[i + 1][j + 1] + arr[i + 2][j + 1]);
		result.push_back(arr[i][j] + arr[i + 1][j] + arr[i + 2][j] + arr[i + 2][j + 1]);
		result.push_back(arr[i][j + 1] + arr[i + 1][j + 1] + arr[i + 2][j + 1] + arr[i + 2][j]);

		result.push_back(arr[i][j] + arr[i + 1][j] + arr[i + 1][j + 1] + arr[i + 2][j + 1]);
		result.push_back(arr[i][j + 1] + arr[i + 1][j + 1] + arr[i + 1][j] + arr[i + 2][j]);

		result.push_back(arr[i][j] + arr[i + 1][j] + arr[i + 2][j] + arr[i + 1][j + 1]);
		result.push_back(arr[i][j+1] + arr[i + 1][j + 1] + arr[i + 2][j + 1] + arr[i+1][j]);

		return *max_element(result.begin(), result.end());
	}
	return 0;
}

int tetr5(const vector<vector<int>>& arr, int N, int M, int i, int j) {
	if (i + 1 < N && j + 1 < M) {
		return arr[i][j] + arr[i][j + 1] + arr[i + 1][j] + arr[i + 1][j + 1];
	}
	return 0;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int N, M;
	cin >> N >> M;

	vector<vector<int>> arr;
	arr.assign(N, vector<int>(M, 0));

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> arr[i][j];
		}
	}

	vector<int> result;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			result.push_back(tetr1_1(arr, N, M, i, j));
			result.push_back(tetr1_2(arr, N, M, i, j));
			result.push_back(tetr234_1(arr, N, M, i, j));
			result.push_back(tetr234_2(arr, N, M, i, j));
			result.push_back(tetr5(arr, N, M, i, j));
		}
	}


	cout << *max_element(result.begin(), result.end());
}
