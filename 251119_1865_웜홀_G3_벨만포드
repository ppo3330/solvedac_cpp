//O(TC * E * V),  E: N, V: 2*M + W
//벨만포드 알고리즘: 그래프에서 음수 사이클 있는지 확인.
//dist를 이용하고 모두 INF로 둔 상황에서 특정 출발점은 0으로 하고 간선 수만큼 dist를 업데이트 하는걸 N번 반복했을떄 N번쨰에도 갱신된다는 것은 음수 사이클 존재한다는 뜻.

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

int TC, N, M, W;;
vector<pair<int, pair<int, int>>> edges;
vector<int> dist;

bool belman() {
	dist.assign(N + 1, 0);

	for (int i= 1; i < N + 1; i++) {
		bool updated = false;
		for (int j = 0; j < edges.size(); j++) {
			int from = edges[j].first;
			int to = edges[j].second.first;
			int cost = edges[j].second.second;

			if (dist[to] > dist[from] + cost) {
				dist[to] = dist[from] + cost;
				updated = true;

				if (i == N) return true;
			}
		}
		if (!updated) break;
	}

	return false;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);


	cin >> TC;
	for (int tc = 0; tc < TC; tc++) {
		int S, E, T;

		cin >> N >> M >> W;

		edges.clear();

		for (int i = 0; i < M; i++) {
			cin >> S >> E >> T;
			edges.push_back({ S,{E,T} });
			edges.push_back({ E,{S,T} });
		}
		for (int i = 0; i < W; i++) {
			cin >> S >> E >> T;
			edges.push_back({ S,{E,-T} });
		}
		if (belman()) cout << "YES\n";
		else cout << "NO\n";
	}
}
