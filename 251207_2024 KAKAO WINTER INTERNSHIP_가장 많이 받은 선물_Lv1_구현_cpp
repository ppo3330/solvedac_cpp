//O(friends^2 + gifts)
//2차원 배열에 주고받은 양, presents[i][i]는 선물지수를 넣고, 
//준 양이 더 많으면 sum++ 같을때는 지수가 더 클시 ++
//unordered_map 사용법과 string 자르기는 찾아봐서 풀었음. (기억하기)
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

int solution(vector<string> friends, vector<string> gifts) {
    int answer = 0;
    
    vector<vector<int>> presents (friends.size(),vector<int>(friends.size(),0));
    unordered_map<string,int> hash;
    for(int i=0;i<friends.size();i++){
        hash.insert({friends[i],i});
    }
    
    for(int i=0;i<gifts.size();i++){
        int emp = gifts[i].find(' ');
        string a = gifts[i].substr(0,emp);
        string b = gifts[i].substr(emp+1);
        presents[hash[a]][hash[b]]++;
        presents[hash[a]][hash[a]]++;
        presents[hash[b]][hash[b]]--;
    }
    
    vector<int> sums(friends.size(),0);
    
    for(int i=0;i<friends.size();i++){
        for(int j=0;j<friends.size();j++){
            if(i==j) continue;
            if(presents[i][j] > presents[j][i]) sums[i]++;
            else if(presents[i][j] == presents[j][i]){
                if(presents[i][i] > presents[j][j]) sums[i]++;
            }
        }
        answer = max(answer,sums[i]);
    }
    
    return answer;
}
