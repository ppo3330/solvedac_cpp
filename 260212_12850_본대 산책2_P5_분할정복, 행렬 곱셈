//O(log N)
//maps[i][j] 는 i에서 j로 가는 방법의 수이다.
//행렬의 곱으로 경우의 수 확인 가능. 기억하기!
//이때 분할정복을 이용한 제곱을 통해서 log로 시간을 줄임
//using 을 통해서 별칭 사용.

#include <iostream>
#include <vector>


#define LL long long int
#define MOD 1000000007

using namespace std;
using mat = vector<vector<LL>>;

mat maps = {
        {0, 1, 1, 0, 0, 0, 0, 0},
        {1, 0, 1, 1, 1, 0, 0, 0},
        {1, 1, 0, 0, 1, 0, 0, 0},
        {0, 1, 0, 0, 1, 1, 1, 0},
        {0, 1, 1, 1, 0, 1, 0, 0},
        {0, 0, 0, 1, 1, 0, 0, 1},
        {0, 0, 0, 1, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 1, 1, 0}
};
mat mul(mat a, mat b) {
    mat ret(8, vector<LL>(8, 0));
    
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            for (int k = 0; k < 8; k++) {
                ret[i][j] += a[k][j] * b[i][k];
                ret[i][j] %= MOD;
            }
        }
    }

    return ret;
}

mat mulrepeat(int n, mat a) {
    if (n == 1) return a;
    else if (n % 2 == 1) {
        mat tmp = mulrepeat(n - 1, a);
        return mul(tmp,a);
    }
    mat m = mulrepeat(n / 2, a);
    return mul(m, m);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int D;
    cin >> D;

    mat ans = mulrepeat(D, maps);
    cout << ans[0][0];

    
}
