//O(V^2)
//BFS두번으로 트리 지름 찾기
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

vector<vector<pair<int, int>>> graphs;
vector<int> visited;
int V;
int MX = 0;
int MXnode = 1;

void link(int st) {
	int ed, cost;
	while (true) {
		cin >> ed;
		if (ed == -1) return;
		cin >> cost;
		graphs[st].push_back({ ed,cost });
	}
}

void dfs(int n) {
	int curcost = visited[n];
	if (curcost > MX) {
		MX = curcost;
		MXnode = n;
	}
	for (int i = 0; i < graphs[n].size(); i++) {
		int nextNode = graphs[n][i].first;
		int nextCost = graphs[n][i].second;

		if (visited[nextNode] > curcost + nextCost) {
			visited[nextNode] = curcost + nextCost;
			dfs(nextNode);
		}

	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	cin >> V;
	graphs = vector<vector<pair<int, int>>>(V+1);
	visited = vector<int>(V + 1, 1e9);


	for (int i = 1; i < V+1; i++) {
		int n;
		cin >> n;
		link(n);
	}
	

	visited[1] = 0;
	dfs(1);
	visited = vector<int>(V + 1, 1e9);
	visited[MXnode] = 0;
	dfs(MXnode);
	cout << MX;
}
