//O(N*M)
//dfs 이용. 현재 돌고 있는 dfs가 nxt이면 safe가 필요함. 그게 아니라 이전 dfs에서 방문했던 곳이면 safe존이 이미 있음.

#include <iostream>
#include <vector>


using namespace std;

vector<string> map;
vector<vector<int>> visited;
int N, M;
int cnt_safe = 0;

pair<int,int> move(int x, int y, char c) {
    if (c == 'D') {
        return { x + 1,y };
    }
    if (c == 'U') {
        return { x - 1,y };
    }
    if (c == 'L') {
        return { x ,y - 1};
    }
    if (c == 'R') {
        return { x, y + 1};
    }
}

void dfs(int x,int y,int cnt) {
    visited[x][y] = cnt;
    pair<int,int> cord = move(x, y, map[x][y]);
    int nxt = visited[cord.first][cord.second];
    if (nxt == cnt) {
        cnt_safe++;
        return;
    }
    else if (nxt == -1) {
        visited[cord.first][cord.second] = cnt;
        dfs(cord.first, cord.second, cnt);
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);


    cin >> N >> M;

    map.assign(N, "");
    for (int i = 0; i < N; i++) {
        cin >> map[i];
    }
    
    visited.assign(N, vector<int>(M, -1));

    int cnt = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (visited[i][j] != -1) continue;
            dfs(i, j,cnt);
            cnt++;
        }
    }

    cout << cnt_safe;
}
