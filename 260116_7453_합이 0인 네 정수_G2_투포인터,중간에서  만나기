//O(N*N)
//요즘 왤케 어려워...ㅜㅜ
//AB를 합치고 CD를 합치고 그 두 값으로 이분탐색이나 투포인터를 사용하는데
//이분탐색의 경우 equal_range 사용
//투포인터시 값이 같은 경우를 상정해서 left right 조정

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> mat;
vector<vector<int>> dp;


int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N;
	cin >> N;

	vector<vector<int>> arr(4, vector< int>(N, 0));

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < 4; j++)
			cin >> arr[j][i];
	}

	vector<vector<int>> sums(2, vector<int>(0, 0));

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			sums[0].push_back(arr[0][i] + arr[1][j]);
			sums[1].push_back(arr[2][i] + arr[3][j]);
		}
	}
	sort(sums[0].begin(), sums[0].end());
	sort(sums[1].begin(), sums[1].end());

	long long int result = 0;

	int left = 0;
	int right = N * N - 1;

	while (left < N * N and right >= 0) {
		long long n = sums[0][left] + sums[1][right];

		if (n > 0) {
			right--;
		}
		else if (n < 0) {
			left++;
		}
		else {
			int A = sums[0][left];
			int B = sums[1][right];
			long long int cntA = 0;
			long long int cntB = 0;

			while (left < N * N && A == sums[0][left] ) {
				cntA++;
				left++;
			}
			while (right >= 0 && B == sums[1][right]) {
				cntB++;
				right--;
			}

			result += cntA * cntB;
		}
	}


	cout << result;
}

/*
#include <bits/stdc++.h>
for (long long x : AB) {
        auto range = equal_range(CD.begin(), CD.end(), -x);
        result += (range.second - range.first);
    }
*/
